# Phase 1.1: Adaptive Layer Coloring - Research

**Researched:** 2026-01-20
**Domain:** deck.gl layer styling, Vue reactive state management, configuration-driven visualization
**Confidence:** HIGH

## Summary

This phase implements intelligent automatic coloring behavior for the MapCard component based on visible layer relationships. The key insight is that layers sharing the same `linkage.geoProperty` form a "layer group" - they are semantically connected and should coordinate their coloring.

The current codebase already has all the infrastructure needed:
1. `getCardLayers()` in InteractiveDashboard.vue filters layers by `geometryType`
2. `getBaseColor()` in MapCard.vue has a 3-priority color system (dashboard colorBy > layer colorBy > static color)
3. `StyleManager.ts` provides theme-aware colors via CSS variables
4. Layer configs support `linkage.geoProperty` which identifies related layers

The implementation requires adding a **LayerColoringStrategy** manager that analyzes visible layers, detects relationships via shared `geoProperty`, and determines which layers should receive colorBy coloring vs neutral styling.

**Primary recommendation:** Create a `LayerColoringManager` class that computes coloring roles (`primary`/`secondary`/`neutral`) per render cycle, integrated into MapCard's `updateLayers()` function.

## Standard Stack

The implementation uses existing libraries already in the codebase:

### Core (Already Present)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Vue 2.7 | 2.7.x | Composition API for reactive state | Already used throughout |
| deck.gl | 8.x | Layer rendering with updateTriggers | Core visualization |
| TypeScript | 5.x | Type safety for configuration | Codebase standard |

### Supporting (Already Present)
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| StyleManager | local | Theme-aware color access | All color decisions |
| colorSchemes.ts | local | Color utilities | RGB/hex conversion |

**No new dependencies required.** Implementation uses existing patterns.

## Architecture Patterns

### Recommended Project Structure

New files to add within the existing structure:

```
src/plugins/interactive-dashboard/
├── managers/
│   ├── StyleManager.ts          # Existing - theme colors
│   ├── LayerColoringManager.ts  # NEW - layer role computation
│   └── ...
├── components/cards/
│   ├── MapCard.vue              # MODIFY - integrate coloring manager
│   └── ...
└── types/
    └── layerColoring.ts         # NEW - TypeScript interfaces
```

### Pattern 1: Layer Role Computation (Render-Time Strategy)

**What:** Compute layer coloring roles on each render based on currently visible layers
**When to use:** Every time `updateLayers()` is called in MapCard

**Algorithm:**
```typescript
interface LayerColoringRole {
  layerName: string
  role: 'primary' | 'secondary' | 'neutral'
  reason: string
}

function computeLayerRoles(
  visibleLayers: LayerConfig[],
  strategy: 'auto' | 'explicit' | 'all'
): Map<string, LayerColoringRole> {

  // 1. Group layers by shared geoProperty
  const groups = groupLayersByGeoProperty(visibleLayers)

  // 2. For each group, determine coloring strategy
  for (const [geoProperty, layers] of groups) {
    const arcLayers = layers.filter(l => l.type === 'arc')
    const geometryLayers = layers.filter(l => l.type !== 'arc')

    // Rule: If arc + geometries visible together, arc is primary
    if (arcLayers.length > 0 && geometryLayers.length > 0) {
      arcLayers.forEach(l => roles.set(l.name, 'primary'))
      geometryLayers.forEach(l => roles.set(l.name, 'neutral'))
    }
    // Rule: If only geometries visible, first one is primary
    else if (geometryLayers.length === 1) {
      roles.set(geometryLayers[0].name, 'primary')
    }
    // Rule: If multiple geometries, all get colorBy
    else if (geometryLayers.length > 1) {
      geometryLayers.forEach(l => roles.set(l.name, 'primary'))
    }
  }

  return roles
}
```

### Pattern 2: Integration with Existing Color Priority System

**What:** Extend `getBaseColor()` to consult computed layer roles
**When to use:** Inside existing color computation functions

The current priority in `getBaseColor()`:
1. Dashboard-level `colorByAttribute` (from selector)
2. Per-layer `colorBy` config
3. Static `color`/`fillColor` from config

**Modified priority with adaptive coloring:**
1. If layer role is `neutral` -> return neutral theme color immediately
2. Dashboard-level `colorByAttribute` (from selector) - but only if layer role is `primary`
3. Per-layer `colorBy` config
4. Static `color`/`fillColor` from config

### Pattern 3: YAML Configuration Schema Extension

**What:** Add new YAML properties for controlling layer coloring behavior
**When to use:** User wants explicit control over auto-detection

```yaml
# Dashboard-level configuration
map:
  colorBy:
    default: main_mode
    layerStrategy: auto  # NEW: 'auto' | 'explicit' | 'all'
    attributes:
      - attribute: main_mode
        label: Transport Mode
        type: categorical

# Layer-level override
layers:
  - name: od_flow_arcs
    type: arc
    colorByRole: primary   # NEW: 'primary' | 'secondary' | 'neutral' | 'auto'
    # ... other config

  - name: origin_clusters
    type: fill
    colorByRole: neutral   # Force neutral even when single geometry
    # ... other config
```

### Anti-Patterns to Avoid

- **Computing roles in `getBaseColor()`**: This would be called thousands of times per render (once per feature). Compute roles ONCE per `updateLayers()` call.

- **Mutating layer configs**: The layerConfig objects come from props. Never mutate them. Instead, pass computed roles as a separate argument.

- **Ignoring existing static colors**: If a layer has explicit `color` property and `colorByRole` is not set, respect the user's intent for static coloring.

- **Breaking the override hierarchy**: User explicit settings must always win over auto-detection. The order should be: explicit override > auto-detection > fallback.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Theme-aware neutral colors | RGB calculations | `StyleManager.getColor('theme.border.subtle')` | Already mode-aware |
| Layer visibility | Manual filtering | `getCardLayers()` in InteractiveDashboard | Already filters by geometryType |
| Color conversion | Custom hex/rgb | `hexToRgba()` from colorSchemes.ts | Handles edge cases |
| Reactive updates | Manual watchers | `updateTriggers` in deck.gl layers | Automatic rerender |

**Key insight:** The codebase already handles most of the complexity. The new code should integrate with existing patterns, not replace them.

## Common Pitfalls

### Pitfall 1: Forgetting Arc Layer Type Check

**What goes wrong:** Arc layers have different structure than polygon/point layers
**Why it happens:** `type: 'arc'` vs `type: 'polygon'` look similar but arcs have source/target positions
**How to avoid:** Always check `layerConfig.type === 'arc'` before making assumptions about geometry
**Warning signs:** Arc layers not getting colorBy when they should

### Pitfall 2: GeoProperty Case Sensitivity

**What goes wrong:** `cluster_id` !== `Cluster_Id` causes layers not to group
**Why it happens:** GeoJSON properties may have inconsistent casing
**How to avoid:** Normalize geoProperty values when grouping (lowercase comparison)
**Warning signs:** Related layers not being recognized as a group

### Pitfall 3: Update Triggers Missing New Dependencies

**What goes wrong:** Layer colors don't update when geometry type changes
**Why it happens:** deck.gl only re-renders when updateTriggers change
**How to avoid:** Add `layerRoles` or equivalent to all color-related updateTriggers
**Warning signs:** Stale colors after switching geometry type selector

### Pitfall 4: Neutral Color Too Similar to Data Colors

**What goes wrong:** Neutral clusters hard to distinguish from data-colored elements
**Why it happens:** Using gray that conflicts with existing color palette
**How to avoid:** Use `StyleManager.getColor('theme.border.default')` which adapts to mode
**Warning signs:** User confusion about which layers have data vs just boundaries

### Pitfall 5: Performance with Many Layers

**What goes wrong:** Slow render when computing roles for 20+ layers
**Why it happens:** Role computation in wrong part of render cycle
**How to avoid:** Compute roles once in `updateLayers()`, pass as ref to color functions
**Warning signs:** Lag when switching geometry types

## Code Examples

Verified patterns from the existing codebase:

### Getting Layers for a Geometry Type (Already Exists)

```typescript
// Source: InteractiveDashboard.vue:576-606
getCardLayers(card: any): any[] {
  if (!card.layers) return []

  // Filter layers based on geometry type selector
  return card.layers.filter((layer: any) => {
    if (this.geometryType === 'all') return true
    if (!layer.geometryType) return true
    return layer.geometryType === this.geometryType
  }).map((layer: any) => {
    // Apply colorBy attribute from selector if configured
    // BUT only if the layer doesn't already have a color or colorBy property defined
    if (this.colorByAttribute && this.yaml.map?.controls?.colorBy
        && !layer.color && !layer.colorBy) {
      const colorByConfig = this.colorByOptions.find(
        (opt: any) => opt.attribute === this.colorByAttribute
      )
      if (colorByConfig) {
        return {
          ...layer,
          colorBy: {
            attribute: this.colorByAttribute,
            type: colorByConfig.type || 'categorical',
          },
        }
      }
    }
    return layer
  })
}
```

### Color Priority in getBaseColor (Already Exists)

```typescript
// Source: MapCard.vue:1482-1542
function getBaseColor(feature: any, layerConfig: LayerConfig): [number, number, number] {
  // Priority 1: Dashboard-level colorByAttribute
  if (props.colorByAttribute && feature.properties?.[props.colorByAttribute] !== undefined) {
    const attributeValue = feature.properties[props.colorByAttribute]
    const attrConfig = props.colorByOptions.find(opt => opt.attribute === props.colorByAttribute)
    const attrType = attrConfig?.type || 'categorical'
    // ... color computation
  }

  // Priority 2: Per-layer colorBy
  if (layerConfig.colorBy) {
    // ... color computation
  }

  // Priority 3: Static color
  if (layerConfig.color) {
    return hexToRgb(layerConfig.color)
  }

  // Default blue
  return [52, 152, 219]
}
```

### Neutral Color from StyleManager

```typescript
// Source: StyleManager.ts - theme colors
// Use for neutral/secondary layers

// For light mode: #e5e7eb (subtle gray)
// For dark mode: #475569 (slate gray)
const neutralFillColor = StyleManager.getInstance().getColorRGBA('theme.border.default', 40)
const neutralLineColor = StyleManager.getInstance().getColorRGBA('theme.border.default', 180)
```

### New Pattern: Layer Role Computation

```typescript
// NEW CODE - LayerColoringManager.ts
interface LayerGroup {
  geoProperty: string
  layers: LayerConfig[]
  hasArc: boolean
  geometryCount: number
}

export function computeLayerGroups(visibleLayers: LayerConfig[]): Map<string, LayerGroup> {
  const groups = new Map<string, LayerGroup>()

  for (const layer of visibleLayers) {
    const geoProperty = layer.linkage?.geoProperty?.toLowerCase() || `__standalone_${layer.name}`

    if (!groups.has(geoProperty)) {
      groups.set(geoProperty, {
        geoProperty,
        layers: [],
        hasArc: false,
        geometryCount: 0
      })
    }

    const group = groups.get(geoProperty)!
    group.layers.push(layer)

    if (layer.type === 'arc') {
      group.hasArc = true
    } else {
      group.geometryCount++
    }
  }

  return groups
}

export function computeLayerRole(
  layer: LayerConfig,
  group: LayerGroup,
  strategy: 'auto' | 'explicit' | 'all'
): 'primary' | 'secondary' | 'neutral' {
  // Check for explicit override first
  if (layer.colorByRole && layer.colorByRole !== 'auto') {
    return layer.colorByRole
  }

  // Strategy: all - every layer gets colorBy
  if (strategy === 'all') return 'primary'

  // Strategy: explicit - only layers with colorByRole: primary get colorBy
  if (strategy === 'explicit') return 'neutral'

  // Strategy: auto (default)
  // If arc + geometries in same group, arc is primary, geometries neutral
  if (group.hasArc && group.geometryCount > 0) {
    return layer.type === 'arc' ? 'primary' : 'neutral'
  }

  // Single geometry layer gets primary
  if (group.geometryCount === 1 && layer.type !== 'arc') {
    return 'primary'
  }

  // Multiple geometries without arc - all get primary
  return 'primary'
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Static layer colors only | colorBy attribute system | Phase 1 | Dynamic data-driven coloring |
| Per-layer color config | Dashboard colorBy selector | Phase 1 | Global color control |
| Hardcoded colors | StyleManager CSS variables | Phase 1 | Theme-aware coloring |

**What this phase adds:**
- Automatic role detection based on layer relationships
- Intelligent coloring when multiple related layers are visible
- Neutral styling for secondary geometry layers
- YAML configuration for explicit control

## Open Questions

Things that couldn't be fully resolved:

1. **What if layers in a group have different linkage.tableColumn?**
   - What we know: `geoProperty` is the joining key (e.g., `cluster_id`)
   - What's unclear: Should layers with same geoProperty but different tableColumn be grouped?
   - Recommendation: Group by geoProperty only - tableColumn affects data filtering, not visual relationship

2. **Should neutral layers respond to hover/select?**
   - What we know: Current behavior highlights all layers on hover
   - What's unclear: Should neutral layers be dimmed/hidden or just have neutral fill?
   - Recommendation: Neutral layers should still show hover/select highlights but with neutral base color

3. **What about layers without linkage config?**
   - What we know: Not all layers have linkage
   - What's unclear: How to handle standalone decorative layers
   - Recommendation: Layers without linkage get their own group, always primary role

## Sources

### Primary (HIGH confidence)
- `/mnt/Shared/Code/projects/Dissertation/simwrapper/src/plugins/interactive-dashboard/components/cards/MapCard.vue` - Current color implementation (lines 1482-1542)
- `/mnt/Shared/Code/projects/Dissertation/simwrapper/src/plugins/interactive-dashboard/InteractiveDashboard.vue` - getCardLayers method (lines 576-606)
- `/mnt/Shared/Code/projects/Dissertation/simwrapper/src/plugins/interactive-dashboard/managers/StyleManager.ts` - Theme color API
- `/mnt/Shared/Code/projects/Dissertation/simwrapper/src/plugins/interactive-dashboard/managers/LinkageManager.ts` - Linkage configuration types

### Secondary (MEDIUM confidence)
- `/mnt/Shared/Code/projects/Dissertation/simwrapper/src/plugins/interactive-dashboard/examples/commuter-requests/example-data/dashboard-interactive-commuter-requests.yaml` - Real YAML config showing layer relationships
- `/mnt/Shared/Code/projects/Dissertation/simwrapper/.planning/phases/01-theming-foundation/01-CONTEXT.md` - Theming decisions that apply to this phase

### Design Decisions (HIGH confidence - from phase description)
- Layer relationship detection via shared `linkage.geoProperty`
- Automatic strategy: arc colored when arc + geometry visible, geometry colored when alone
- YAML configuration: `layerStrategy` and `colorByRole` properties

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - all libraries already in codebase
- Architecture: HIGH - extends existing patterns with clear integration points
- Pitfalls: HIGH - based on actual code analysis of current implementation

**Research date:** 2026-01-20
**Valid until:** 60 days (stable codebase, no external dependencies)
