---
phase: 01.1-adaptive-layer-coloring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/plugins/interactive-dashboard/types/layerColoring.ts
  - src/plugins/interactive-dashboard/managers/LayerColoringManager.ts
  - src/plugins/interactive-dashboard/managers/__tests__/LayerColoringManager.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Layers with same geoProperty are grouped together"
    - "Role computation correctly identifies primary vs neutral layers"
    - "Arc layers become primary when visible with geometry layers"
    - "Single geometry layer becomes primary when alone"
  artifacts:
    - path: "src/plugins/interactive-dashboard/types/layerColoring.ts"
      provides: "TypeScript interfaces for layer coloring"
      exports: ["LayerColoringRole", "LayerGroup", "LayerStrategy", "ColorByRole"]
    - path: "src/plugins/interactive-dashboard/managers/LayerColoringManager.ts"
      provides: "Layer role computation logic"
      exports: ["LayerColoringManager", "computeLayerGroups", "computeLayerRole"]
    - path: "src/plugins/interactive-dashboard/managers/__tests__/LayerColoringManager.test.ts"
      provides: "Test coverage for role computation"
      min_lines: 100
  key_links:
    - from: "LayerColoringManager.ts"
      to: "LayerConfig.linkage.geoProperty"
      via: "grouping algorithm"
      pattern: "geoProperty"
---

<objective>
Create the LayerColoringManager class with TypeScript types that computes layer coloring roles based on visible layer relationships.

Purpose: This manager analyzes which layers are visible and determines which should receive colorBy coloring (primary) vs neutral styling, based on shared geoProperty relationships.

Output: New manager class with types, ready for integration into MapCard in the next plan.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-adaptive-layer-coloring/01.1-RESEARCH.md

# Existing code to reference
@src/plugins/interactive-dashboard/managers/StyleManager.ts
@src/plugins/interactive-dashboard/managers/LinkageManager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript types for layer coloring</name>
  <files>src/plugins/interactive-dashboard/types/layerColoring.ts</files>
  <action>
Create new types file with interfaces for layer coloring system:

```typescript
/**
 * Layer coloring role - determines how a layer receives colors
 */
export type ColorByRole = 'primary' | 'secondary' | 'neutral' | 'auto'

/**
 * Dashboard-level strategy for automatic role assignment
 */
export type LayerStrategy = 'auto' | 'explicit' | 'all'

/**
 * Computed role for a specific layer
 */
export interface LayerColoringRole {
  layerName: string
  role: 'primary' | 'secondary' | 'neutral'
  reason: string
}

/**
 * Group of layers sharing the same geoProperty
 */
export interface LayerGroup {
  geoProperty: string
  layers: LayerConfig[]
  hasArc: boolean
  geometryCount: number
}

/**
 * Minimal layer config interface for typing
 * (matches relevant parts of existing LayerConfig)
 */
export interface LayerConfigForColoring {
  name: string
  type: string
  linkage?: {
    geoProperty?: string
    tableColumn?: string
  }
  colorByRole?: ColorByRole
  color?: string
  fillColor?: string
  colorBy?: any
}
```

Include JSDoc comments explaining each type's purpose.
  </action>
  <verify>TypeScript compiles without errors: `cd /mnt/Shared/Code/projects/Dissertation/simwrapper && npx tsc --noEmit 2>&1 | head -20`</verify>
  <done>Types file exists with all interfaces exported, TypeScript compilation succeeds</done>
</task>

<task type="auto">
  <name>Task 2: Create LayerColoringManager class</name>
  <files>src/plugins/interactive-dashboard/managers/LayerColoringManager.ts</files>
  <action>
Create the LayerColoringManager class with these functions:

1. **computeLayerGroups(visibleLayers)**: Groups layers by shared `linkage.geoProperty`
   - Normalize geoProperty to lowercase for case-insensitive matching
   - Layers without linkage get their own standalone group
   - Track hasArc and geometryCount per group

2. **computeLayerRole(layer, group, strategy)**: Determines role for a single layer
   - Check explicit `colorByRole` override first (if not 'auto')
   - Strategy 'all': Return 'primary' for all layers
   - Strategy 'explicit': Return 'neutral' unless layer has colorByRole: primary
   - Strategy 'auto' (default):
     - If group has arc + geometries: arc is primary, geometries are neutral
     - If single geometry: primary
     - If multiple geometries without arc: all primary

3. **computeAllLayerRoles(visibleLayers, strategy)**: Main entry point
   - Calls computeLayerGroups
   - Calls computeLayerRole for each layer
   - Returns Map<string, LayerColoringRole> keyed by layer name

Follow the algorithm from RESEARCH.md exactly. Use the StyleManager pattern for class structure (singleton not needed here - this is per-render computation).

Export all three functions plus the class for flexibility.
  </action>
  <verify>TypeScript compiles without errors: `cd /mnt/Shared/Code/projects/Dissertation/simwrapper && npx tsc --noEmit 2>&1 | head -20`</verify>
  <done>LayerColoringManager.ts exports computeLayerGroups, computeLayerRole, computeAllLayerRoles</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for LayerColoringManager</name>
  <files>src/plugins/interactive-dashboard/managers/__tests__/LayerColoringManager.test.ts</files>
  <action>
Create test file following the StyleManager.test.ts pattern. Test these scenarios:

**Group computation tests:**
- Layers with same geoProperty are grouped together
- Case-insensitive geoProperty matching (cluster_id == Cluster_Id)
- Layers without linkage get standalone groups
- hasArc and geometryCount correctly computed

**Role computation tests - auto strategy:**
- Arc + polygon layers: arc=primary, polygon=neutral
- Arc + polygon + polygon: arc=primary, both polygons=neutral
- Single polygon alone: primary
- Two polygons without arc: both primary
- Arc alone: primary

**Role computation tests - explicit strategy:**
- Layer with colorByRole:primary gets primary
- Layer with colorByRole:neutral gets neutral
- Layer without colorByRole gets neutral

**Role computation tests - all strategy:**
- All layers get primary regardless of relationships

**Override tests:**
- Explicit colorByRole overrides auto-detection
- colorByRole:'auto' defers to auto-detection

Use vitest describe/it/expect pattern. Include edge cases like empty layer arrays.
  </action>
  <verify>Tests pass: `cd /mnt/Shared/Code/projects/Dissertation/simwrapper && npm run test:run -- --reporter=verbose LayerColoringManager 2>&1 | tail -30`</verify>
  <done>All tests pass, covering grouping, role computation for all strategies, and override behavior</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Tests pass: `npm run test:run -- LayerColoringManager`
3. Types are exported: Check that `import { LayerColoringRole, computeAllLayerRoles } from ...` works
</verification>

<success_criteria>
- Types file exists with LayerColoringRole, LayerGroup, LayerStrategy, ColorByRole exports
- LayerColoringManager.ts implements grouping and role computation algorithms
- Test file has 10+ test cases covering all strategies and edge cases
- All tests pass
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-adaptive-layer-coloring/01.1-01-SUMMARY.md`
</output>
