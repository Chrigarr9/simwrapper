---
phase: 02-sub-dashboard-fix
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/plugins/interactive-dashboard/components/FullscreenPortal.vue
  - src/plugins/interactive-dashboard/InteractiveDashboard.vue
autonomous: false

must_haves:
  truths:
    - "MapCard in sub-dashboard can be enlarged and map renders correctly"
    - "DataTableCard in sub-dashboard can be enlarged and maintains scroll/sort"
    - "HistogramCard in sub-dashboard can be enlarged and maintains hover/filter"
    - "Close button visible in fullscreen mode"
  artifacts:
    - path: "src/plugins/interactive-dashboard/components/FullscreenPortal.vue"
      provides: "Polished portal with visible close button and transitions"
      contains: "fa-compress"
  key_links:
    - from: "InteractiveDashboard.vue"
      to: "MapCard component key"
      via: "key prop changes on fullscreen toggle causing remount"
      pattern: ":key=.*fullScreenCardId"
---

<objective>
Verify and polish fullscreen behavior across all card types

Purpose: Ensure all interactive dashboard card types (MapCard, DataTableCard, HistogramCard, PieChartCard, ScatterCard) work correctly in fullscreen mode from sub-dashboards. MapCard uses deck.gl which may lose WebGL context when DOM is teleported, requiring key-based remount.

Output: Verified fullscreen functionality for all card types with polished UX
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-sub-dashboard-fix/02-01-SUMMARY.md

# Relevant source files
@src/plugins/interactive-dashboard/components/FullscreenPortal.vue
@src/plugins/interactive-dashboard/components/cards/MapCard.vue
@src/plugins/interactive-dashboard/components/cards/DataTableCard.vue
@src/plugins/interactive-dashboard/components/cards/HistogramCard.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add visual close button and transitions to FullscreenPortal</name>
  <files>src/plugins/interactive-dashboard/components/FullscreenPortal.vue</files>
  <action>
Polish the FullscreenPortal component with clear visual affordances.

**Add a close button directly in the portal container** (created in createPortalContainer):

```typescript
createPortalContainer(): HTMLElement {
  const container = document.createElement('div')
  container.className = 'fullscreen-portal-container'

  // Apply fullscreen styles
  Object.assign(container.style, {
    position: 'fixed',
    top: '0',
    left: '0',
    right: '0',
    bottom: '0',
    zIndex: '10000',
    backgroundColor: 'var(--dashboard-bg-primary, var(--bgBold, #1a1a2e))',
    display: 'flex',
    flexDirection: 'column',
    padding: '1rem',
    opacity: '0',
    transition: 'opacity 0.2s ease-in-out'
  })

  // Add close button using DOM APIs (safe, no XSS risk)
  const closeBtn = document.createElement('button')
  closeBtn.className = 'fullscreen-close-btn'
  closeBtn.title = 'Close (Escape)'

  // Create icon element safely using DOM API
  const icon = document.createElement('i')
  icon.className = 'fa fa-compress'
  closeBtn.appendChild(icon)

  Object.assign(closeBtn.style, {
    position: 'absolute',
    top: '1rem',
    right: '1rem',
    zIndex: '10001',
    background: 'var(--dashboard-bg-secondary, rgba(0,0,0,0.5))',
    border: '1px solid var(--dashboard-border-default, rgba(255,255,255,0.2))',
    borderRadius: '4px',
    color: 'var(--dashboard-text-primary, white)',
    padding: '0.5rem 0.75rem',
    cursor: 'pointer',
    fontSize: '1rem'
  })
  closeBtn.addEventListener('click', () => this.$emit('close'))
  container.appendChild(closeBtn)

  // Fade in after adding to DOM
  requestAnimationFrame(() => {
    container.style.opacity = '1'
  })

  return container
}
```

**Add fade-out on deactivate:**

```typescript
deactivatePortal() {
  if (!this.portalContainer) return

  // Fade out first
  this.portalContainer.style.opacity = '0'

  // Wait for transition then move content back
  setTimeout(() => {
    const origin = this.$refs.origin as HTMLElement
    if (origin && this.portalContainer) {
      // Move all children EXCEPT the close button back to origin
      const children = Array.from(this.portalContainer.children)
      for (const child of children) {
        if (!child.classList.contains('fullscreen-close-btn')) {
          origin.appendChild(child)
        }
      }

      // Remove portal container from body
      if (this.portalContainer.parentNode) {
        this.portalContainer.parentNode.removeChild(this.portalContainer)
      }
    }

    // Remove Escape key listener
    document.removeEventListener('keydown', this.handleKeydown)

    // Trigger resize event
    this.$nextTick(() => {
      window.dispatchEvent(new Event('resize'))
    })
  }, 200) // Match transition duration
}
```
  </action>
  <verify>
- Close button visible in top-right when fullscreen active
- Click on close button triggers close event
- Transition is smooth (fade in/out over 0.2s)
  </verify>
  <done>
FullscreenPortal has visible close button and smooth transitions
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement key-based remount for MapCard WebGL context</name>
  <files>src/plugins/interactive-dashboard/InteractiveDashboard.vue</files>
  <action>
MapCard uses deck.gl which creates WebGL contexts. When DOM nodes are teleported via portal, WebGL contexts are lost and cannot be recovered. The solution is to force Vue to destroy and recreate the component using a key that changes on fullscreen toggle.

**Modify the component rendering to include fullscreen state in the key:**

In the template where cards are rendered (both linkable and non-linkable versions), change the key prop:

**For linkable cards (around line 78):**
```pug
component.dash-card(v-if="card.visible"
  :is="getCardComponent(card)"
  :key="`${card.id}-${embedded && fullScreenCardId === card.id ? 'fullscreen' : 'normal'}`"
  //- ... rest of props unchanged
)
```

**For non-linkable cards (around line 133):**
```pug
component.dash-card(v-else-if="card.visible"
  :is="getCardComponent(card)"
  :key="`${card.id}-${embedded && fullScreenCardId === card.id ? 'fullscreen' : 'normal'}`"
  //- ... rest of props unchanged
)
```

**Why this works:**
1. When user clicks enlarge, `fullScreenCardId` changes to `card.id`
2. The key changes from `card-id-1-normal` to `card-id-1-fullscreen`
3. Vue sees a different key and destroys the old component, creates a new one
4. The new MapCard initializes a fresh deck.gl instance inside the portal container
5. When user exits fullscreen, key changes back, component remounts in original location

**Why not try to preserve WebGL context:**
- `preserveDrawingBuffer` is a context creation parameter, not a post-creation fix
- Moving a canvas with WebGL context to a different DOM location breaks the context
- Remounting is the cleanest, most reliable solution

**Ensure FullscreenPortal triggers resize after remount:**
The FullscreenPortal already dispatches resize event in activatePortal(), which will trigger deck.gl to recalculate dimensions after the new instance mounts.
  </action>
  <verify>
Test procedure:
1. Start dev server: `npm run dev`
2. Open a dashboard with sub-dashboards containing a MapCard
3. Click enlarge on the MapCard
4. **Verify:** Map renders correctly (not blank, layers visible)
5. **Verify:** Pan and zoom work
6. **Verify:** Hover interactions work (tooltips appear)
7. Press Escape to exit fullscreen
8. **Verify:** Map renders correctly back in sub-dashboard
9. Check browser console for WebGL errors (there should be none)
  </verify>
  <done>
MapCard and other cards with complex rendering (WebGL, canvas) work correctly in fullscreen mode via key-based remount strategy
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Sub-dashboard fullscreen functionality for all card types:
- FullscreenPortal component with close button and transitions
- InteractiveDashboard integration for embedded mode
- Key-based remount for MapCard WebGL context preservation
  </what-built>
  <how-to-verify>
1. Start dev server: `npm run dev`
2. Navigate to a dashboard that has sub-dashboards (or create a test config)
3. Expand a sub-dashboard section
4. For each card type in the sub-dashboard:
   - **SUBD-01 check:** Verify enlarge button (expand icon) is visible in card header
   - Click enlarge button
   - Verify card expands to full viewport (not clipped)
   - Verify close button visible in top-right corner
   - Test card interactivity (hover, click, zoom for maps)
   - Click close button OR press Escape
   - Verify card returns to original position in sub-dashboard

Test specifically:
- [ ] MapCard: Pan/zoom, hover highlights, layer visibility
- [ ] DataTableCard: Scroll, sort columns, row selection
- [ ] HistogramCard: Hover bars, filter by clicking
- [ ] Any other card types present

Check for:
- [ ] No visual glitches during open/close transition
- [ ] No console errors (especially WebGL errors)
- [ ] Z-index correct (fullscreen card above everything)
  </how-to-verify>
  <resume-signal>Type "approved" if all card types work correctly, or describe specific issues found</resume-signal>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. All card types work in sub-dashboard fullscreen mode
3. No console errors during fullscreen transitions
4. User verification of visual quality and interactions
</verification>

<success_criteria>
- All success criteria from 02-01 still pass
- Close button clearly visible and functional
- Smooth transitions (no jarring state changes)
- MapCard maintains full interactivity (pan, zoom, hover, select)
- DataTableCard maintains scroll and sort functionality
- Chart cards maintain hover and filter interactions
- Human verification approves the implementation
</success_criteria>

<output>
After completion, create `.planning/phases/02-sub-dashboard-fix/02-02-SUMMARY.md`
</output>
