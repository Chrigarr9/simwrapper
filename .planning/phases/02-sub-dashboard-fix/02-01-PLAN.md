---
phase: 02-sub-dashboard-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/plugins/interactive-dashboard/components/FullscreenPortal.vue
  - src/plugins/interactive-dashboard/components/cards/SubDashboard.vue
  - src/plugins/interactive-dashboard/InteractiveDashboard.vue
autonomous: true

must_haves:
  truths:
    - "Enlarge button appears on card headers within sub-dashboards"
    - "Clicking enlarge on sub-dashboard card expands to full viewport"
    - "Escape key or close button returns card to original position"
    - "Enlarged card is fully visible without clipping or overlay issues"
  artifacts:
    - path: "src/plugins/interactive-dashboard/components/FullscreenPortal.vue"
      provides: "Portal component for teleporting content to document.body"
      exports: ["default"]
    - path: "src/plugins/interactive-dashboard/InteractiveDashboard.vue"
      provides: "Updated dashboard using FullscreenPortal when embedded prop is true"
      contains: "FullscreenPortal"
  key_links:
    - from: "InteractiveDashboard.vue"
      to: "FullscreenPortal.vue"
      via: "component import when embedded=true"
      pattern: "import FullscreenPortal|<fullscreen-portal"
    - from: "FullscreenPortal.vue"
      to: "document.body"
      via: "DOM appendChild when active"
      pattern: "document\\.body\\.appendChild"
---

<objective>
Implement fullscreen portal pattern for sub-dashboard cards

Purpose: Sub-dashboard cards are trapped by CSS containment (`contain: layout`) which prevents `position: fixed` from working. This plan implements a portal pattern that teleports enlarged content to document.body, bypassing all parent CSS containment.

Output: FullscreenPortal component and updated InteractiveDashboard with working enlarge functionality when embedded in sub-dashboards
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/PITFALLS.md (Pitfall #4: CSS Containment Blocking Card Enlargement)

# Relevant source files
@src/plugins/interactive-dashboard/components/cards/SubDashboard.vue
@src/plugins/interactive-dashboard/components/cards/DataTableCard.vue (existing fullscreen pattern)
@src/plugins/interactive-dashboard/InteractiveDashboard.vue (existing toggleZoom pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FullscreenPortal component</name>
  <files>src/plugins/interactive-dashboard/components/FullscreenPortal.vue</files>
  <action>
Create a Vue 2.7 component that teleports its slot content to document.body when active.

**Props:**
- `active: boolean` - controls whether content is teleported

**Events:**
- `close` - emitted when close button clicked or Escape pressed

**Implementation (Vue 2 Options API for compatibility):**

```vue
<template lang="pug">
.fullscreen-portal-wrapper
  //- Original slot location (content rendered here normally)
  .portal-origin(ref="origin" v-show="!active")
    slot
  //- When active, content is moved to portal container on document.body
</template>

<script lang="ts">
import Vue from 'vue'

export default Vue.extend({
  name: 'FullscreenPortal',
  props: {
    active: { type: Boolean, default: false }
  },
  data() {
    return {
      portalContainer: null as HTMLElement | null
    }
  },
  watch: {
    active: {
      handler(isActive: boolean) {
        if (isActive) {
          this.activatePortal()
        } else {
          this.deactivatePortal()
        }
      },
      immediate: false
    }
  },
  methods: {
    createPortalContainer(): HTMLElement {
      const container = document.createElement('div')
      container.className = 'fullscreen-portal-container'
      // Apply fullscreen styles directly (z-index higher than DataTableCard's 9999)
      Object.assign(container.style, {
        position: 'fixed',
        top: '0',
        left: '0',
        right: '0',
        bottom: '0',
        zIndex: '10000',
        backgroundColor: 'var(--dashboard-bg-primary, var(--bgBold, #1a1a2e))',
        display: 'flex',
        flexDirection: 'column',
        padding: '1rem'
      })
      return container
    },
    activatePortal() {
      // Create portal container if it doesn't exist
      if (!this.portalContainer) {
        this.portalContainer = this.createPortalContainer()
      }

      // Move slot content to portal container
      const origin = this.$refs.origin as HTMLElement
      if (origin && origin.firstChild) {
        // Append portal container to body
        document.body.appendChild(this.portalContainer)

        // Move content from origin to portal
        while (origin.firstChild) {
          this.portalContainer.appendChild(origin.firstChild)
        }

        // Add Escape key listener
        document.addEventListener('keydown', this.handleKeydown)

        // Trigger resize event after DOM settles
        this.$nextTick(() => {
          window.dispatchEvent(new Event('resize'))
        })
      }
    },
    deactivatePortal() {
      if (!this.portalContainer) return

      // Move content back to origin
      const origin = this.$refs.origin as HTMLElement
      if (origin && this.portalContainer) {
        while (this.portalContainer.firstChild) {
          // Skip close button (it's part of portal container, not content)
          const child = this.portalContainer.firstChild
          origin.appendChild(child)
        }

        // Remove portal container from body
        if (this.portalContainer.parentNode) {
          this.portalContainer.parentNode.removeChild(this.portalContainer)
        }
      }

      // Remove Escape key listener
      document.removeEventListener('keydown', this.handleKeydown)

      // Trigger resize event
      this.$nextTick(() => {
        window.dispatchEvent(new Event('resize'))
      })
    },
    handleKeydown(e: KeyboardEvent) {
      if (e.key === 'Escape') {
        this.$emit('close')
      }
    }
  },
  beforeDestroy() {
    // Cleanup: deactivate and remove listeners
    this.deactivatePortal()
    if (this.portalContainer && this.portalContainer.parentNode) {
      this.portalContainer.parentNode.removeChild(this.portalContainer)
    }
  }
})
</script>

<style scoped lang="scss">
.fullscreen-portal-wrapper {
  display: contents; // Wrapper doesn't affect layout
}

.portal-origin {
  display: contents; // Origin doesn't affect layout when visible
}
</style>
```

Note: The portal teleports the entire card frame (including header with enlarge/close buttons) so users can always close the fullscreen view.
  </action>
  <verify>
- Component file exists at `src/plugins/interactive-dashboard/components/FullscreenPortal.vue`
- No TypeScript errors: `npx vue-tsc --noEmit 2>&1 | grep -i FullscreenPortal || echo "No errors"`
- Component exports default
  </verify>
  <done>
FullscreenPortal component exists with:
- active prop controlling teleportation
- Slot content moves to document.body when active
- Escape key emits close event
- Proper cleanup on deactivation/unmount
  </done>
</task>

<task type="auto">
  <name>Task 2: Update InteractiveDashboard to use FullscreenPortal when embedded</name>
  <files>src/plugins/interactive-dashboard/InteractiveDashboard.vue</files>
  <action>
Modify InteractiveDashboard.vue to use FullscreenPortal for card fullscreen when in embedded mode (sub-dashboard context).

**Changes:**

1. Import FullscreenPortal component:
```typescript
import FullscreenPortal from './components/FullscreenPortal.vue'
```

2. Register in components:
```typescript
components: Object.assign({ TopSheet, LinkableCardWrapper, DataTableCard, LinkedTableCard, SubDashboard, FullscreenPortal }, namedCharts),
```

3. Modify the template card rendering (around line 32) to wrap the entire `.dash-card-frame` with FullscreenPortal when embedded:

**Before (existing structure):**
```pug
.dash-card-frame(v-for="card,j in row.cards" ...)
  .dash-card-headers(...)
    //- buttons including enlarge
  //- card content
```

**After (wrap with portal when embedded):**
```pug
//- Wrap entire card frame with portal when in embedded mode
fullscreen-portal(
  v-if="embedded"
  :active="fullScreenCardId === card.id"
  @close="toggleZoom(card)"
)
  .dash-card-frame(v-for="card,j in row.cards" ...)
    .dash-card-headers(...)
      //- existing header with enlarge button (no changes needed)
    //- card content

//- Non-embedded: render without portal (existing behavior)
.dash-card-frame(v-else v-for="card,j in row.cards" ...)
  //- existing structure unchanged
```

**Important:** The portal wraps the ENTIRE `.dash-card-frame` including:
- `.dash-card-headers` with title, description, and enlarge button
- `.spinner-box` with card content
- Error display

This ensures the enlarge button and close functionality remain accessible when teleported.

4. Handle Escape key at dashboard level as backup (add to mounted/beforeDestroy):
```typescript
mounted() {
  // ... existing code ...
  if (this.embedded) {
    window.addEventListener('keydown', this.handleEscapeKey)
  }
}

beforeDestroy() {
  // ... existing code ...
  window.removeEventListener('keydown', this.handleEscapeKey)
}

methods: {
  // Add new method
  handleEscapeKey(e: KeyboardEvent) {
    if (e.key === 'Escape' && this.fullScreenCardId) {
      this.fullScreenCardId = ''
    }
  },
  // ... existing methods ...
}
```
  </action>
  <verify>
- InteractiveDashboard imports FullscreenPortal
- FullscreenPortal is registered in components
- Template wraps card frame with portal when embedded=true
- Escape key handler added for embedded mode
- Build passes: `npm run build`
  </verify>
  <done>
InteractiveDashboard.vue:
- Uses FullscreenPortal for card fullscreen in embedded/sub-dashboard context
- Entire card frame (including header with buttons) gets teleported
- Escape key closes fullscreen
  </done>
</task>

<task type="auto">
  <name>Task 3: Update SubDashboard CSS containment</name>
  <files>src/plugins/interactive-dashboard/components/cards/SubDashboard.vue</files>
  <action>
Modify SubDashboard.vue to remove or adjust `contain: layout` CSS rule that blocks fullscreen.

**Change the CSS:**

```scss
.sub-dashboard-wrapper {
  background: #1a1a2e;
  border: 2px solid #3a3a5e;
  border-radius: 8px;
  margin-top: 1.5rem;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  position: relative;
  // REMOVE: contain: layout;
  // The portal pattern handles escaping containment by teleporting to body
}
```

**Why remove `contain: layout`:**
- The portal already teleports fullscreen content to document.body
- `contain: layout` was preventing position:fixed from working, but now we bypass it entirely
- Removing it simplifies the solution and avoids any residual containment issues

SubDashboard.vue does NOT need to import or use FullscreenPortal - it simply renders an embedded InteractiveDashboard, and InteractiveDashboard handles the portal when `embedded=true`.
  </action>
  <verify>
- SubDashboard.vue no longer has `contain: layout` in its CSS
- Build passes: `npm run build`
- Dev server starts without errors: `npm run dev`
  </verify>
  <done>
SubDashboard.vue:
- CSS containment removed (portal handles escape)
- No FullscreenPortal import needed (InteractiveDashboard handles it)
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build` completes without errors
2. Dev server starts: `npm run dev`
3. Open a dashboard with sub-dashboards in browser
4. **SUBD-01 verification:** Verify enlarge button (fa-expand icon) appears on sub-dashboard card headers
5. Click enlarge - card should expand to full viewport (not clipped by sub-dashboard container)
6. Press Escape - card should return to original position
7. Enlarged card should allow hover, select, zoom interactions
</verification>

<success_criteria>
- SUBD-01: Enlarge button visible on sub-dashboard card headers (existing button, now functional)
- SUBD-02: Enlarged card breaks out to full viewport (not clipped by sub-dashboard container)
- Escape key closes fullscreen view
- Card maintains interactivity in fullscreen mode
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-sub-dashboard-fix/02-01-SUMMARY.md`
</output>
