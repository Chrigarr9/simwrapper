# Phase 3.1: Comparison Mode - Research

**Researched:** 2026-01-21
**Domain:** Interactive visualization comparison patterns with Plotly.js
**Confidence:** HIGH

## Summary

Comparison mode enables users to visually compare filtered data against baseline (all data) across multiple visualization types. This is a proven pattern in the codebase, with a complete reference implementation in the `commuter-requests` plugin that provides all necessary techniques for generalizing to the interactive-dashboard.

The core technique is **dual-dataset rendering**: each visualization card receives both `baselineData` (all data) and `filteredData`, then conditionally overlays them based on comparison toggle state and filter activity. The pattern is implemented differently for each chart type:
- **Histograms**: Plotly barmode 'overlay' with semi-transparent baseline bars behind filtered bars
- **Pie charts**: Concentric donuts with inner ring (filtered) and outer ring (baseline)
- **Scatter plots**: Baseline points rendered first (gray), filtered points on top (colored)
- **Data tables**: "Filtered / Baseline" count display in header

**Primary recommendation:** Generalize the existing `commuter-requests` implementation patterns to the interactive-dashboard plugin by adding comparison state management at dashboard level and passing both datasets to all visualization cards.

## Standard Stack

The established libraries/tools for comparison mode visualization:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| plotly.js | 3.1.0 | Chart rendering | Already used for histograms, pies, and scatter plots in interactive-dashboard cards |
| Vue 2.7 | 2.7.16 | Reactivity | Existing framework - comparison state managed as reactive data property |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| StyleManager | (internal) | Theme-aware colors | Existing utility for consistent baseline/filtered styling across light/dark modes |
| FilterManager | (internal) | Filter state tracking | Already manages filter state - extend to provide hasActiveFilters() check |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Dual-dataset approach | Single dataset with visual layers | Dual-dataset is cleaner - no need to track which data points belong to which set during rendering |
| Plotly overlay | D3.js custom rendering | Plotly is already integrated and handles responsive resizing, dark mode, and interaction events |
| Dashboard-level toggle | Card-level toggles | Dashboard-level provides consistent UX and simpler state management |

**Installation:**
No new dependencies required - all libraries already in package.json.

## Architecture Patterns

### Recommended Project Structure
```
src/plugins/interactive-dashboard/
├── components/
│   ├── controls/
│   │   └── ComparisonToggle.vue       # Toggle UI component (NEW)
│   ├── cards/
│   │   ├── HistogramCard.vue          # Add baselineData prop, overlay rendering
│   │   ├── PieChartCard.vue           # Add baselineData prop, concentric rings
│   │   ├── ScatterCard.vue            # Add baselineData prop, layered points
│   │   └── DataTableCard.vue          # Add baseline count display
│   └── LinkableCardWrapper.vue        # Pass baselineData from dataTableManager
├── managers/
│   └── DataTableManager.ts            # Already provides getData() for baseline
└── InteractiveDashboard.vue           # Add showComparison state, comparison toggle control
```

### Pattern 1: Conditional Comparison Display
**What:** Comparison mode only activates when filters are active (avoids meaningless "all vs all" comparison)
**When to use:** Dashboard-level computed property
**Example:**
```typescript
// Source: commuter-requests/CommuterRequests.vue:390-392
const effectiveShowComparison = computed(() => {
  return showComparison.value && hasActiveFilters.value
})
```

### Pattern 2: Dual-Dataset Props
**What:** Pass both baseline and filtered data to visualization cards
**When to use:** All chart cards that support comparison mode
**Example:**
```typescript
// Source: commuter-requests/components/stats/ActiveTimeHistogramPlotly.vue:29-31
props: {
  requests: { type: Array as PropType<Request[]>, required: true },           // Filtered
  baselineRequests: { type: Array as PropType<Request[]>, default: () => [] }, // Baseline
  showComparison: { type: Boolean, default: false },
}
```

### Pattern 3: Overlay Histogram (Plotly barmode)
**What:** Render baseline bars with low opacity behind filtered bars
**When to use:** HistogramCard when comparison mode active
**Example:**
```typescript
// Source: commuter-requests/components/stats/ActiveTimeHistogramPlotly.vue:56-67
const plotData = computed(() => {
  const data: any[] = []

  // Baseline trace - shown with lower saturation in background
  if (showComparison && baselineBins.length > 0) {
    data.push({
      x: baselineBins.map(b => b.label),
      y: baselineBins.map(b => b.count),
      type: 'bar',
      name: 'All Requests (Baseline)',
      marker: { color: 'rgba(156, 163, 175, 0.3)' }, // Low opacity
      hovertemplate: '<b>%{x}</b><br>Baseline: %{y}<extra></extra>',
    })
  }

  // Filtered trace - highlighted on top
  data.push({
    x: bins.map(b => b.label),
    y: bins.map(b => b.count),
    type: 'bar',
    name: showComparison ? 'Filtered' : 'Data',
    marker: { color: /* selection-aware colors */ },
  })

  return data
})

const plotLayout = computed(() => ({
  // ... other layout config
  barmode: 'overlay',  // CRITICAL: overlays filtered on top of baseline
}))
```

### Pattern 4: Concentric Donut Chart
**What:** Render baseline as outer ring (larger hole), filtered as inner ring (smaller hole)
**When to use:** PieChartCard when comparison mode active
**Example:**
```typescript
// Source: commuter-requests/components/stats/MainModePieChartPlotly.vue:59-94
const plotData = computed(() => {
  const data: any[] = []

  // Inner ring - filtered data
  data.push({
    labels: modeData.value.labels,
    values: modeData.value.values,
    type: 'pie',
    hole: 0.4,  // Smaller hole for inner ring
    marker: { colors: /* selection-aware colors */ },
    domain: showComparison ? { x: [0.15, 0.85], y: [0.15, 0.85] } : undefined,
  })

  // Outer ring - baseline data (if comparison mode)
  if (showComparison && baselineModeData.value.labels.length > 0) {
    data.push({
      labels: baselineModeData.value.labels,
      values: baselineModeData.value.values,
      type: 'pie',
      hole: 0.7,  // Larger hole for outer ring
      marker: { colors: baselineModeData.value.colors.map(c => c + '80') }, // Add transparency
      textinfo: 'none',  // No labels on baseline ring
      hovertemplate: '<b>Baseline: %{label}</b><br>%{value}<extra></extra>',
      domain: { x: [0, 1], y: [0, 1] },  // Full domain
    })
  }

  return data
})
```

### Pattern 5: Layered Scatter Points
**What:** Render baseline points first (gray, low opacity), filtered points on top (colored)
**When to use:** ScatterCard when comparison mode active
**Example:**
```typescript
// Pseudo-code based on histogram/pie patterns
const plotData = computed(() => {
  const traces: any[] = []

  // Baseline trace - render first (appears in background)
  if (showComparison && baselineData.value.length > 0) {
    traces.push({
      x: baselineData.value.map(d => d[xColumn]),
      y: baselineData.value.map(d => d[yColumn]),
      mode: 'markers',
      type: 'scatter',
      name: 'Baseline',
      marker: {
        color: 'rgba(156, 163, 175, 0.3)',  // Gray, low opacity
        size: markerSize * 0.8,              // Slightly smaller
      },
      hoverinfo: 'skip',  // Don't show hover on baseline points
    })
  }

  // Filtered trace - render second (appears on top)
  traces.push({
    x: filteredData.value.map(d => d[xColumn]),
    y: filteredData.value.map(d => d[yColumn]),
    mode: 'markers',
    type: 'scatter',
    name: showComparison ? 'Filtered' : 'Data',
    marker: {
      color: /* selection-aware colors */,
      size: markerSize,
    },
  })

  return traces
})
```

### Pattern 6: Table Count Display
**What:** Show "Filtered / Baseline" ratio when comparison mode active and filters applied
**When to use:** DataTableCard or inline table header
**Example:**
```pug
//- Source: commuter-requests/CommuterRequests.vue:129-131
.stat-row(v-if="effectiveShowComparison && allRequests.length > 0")
  .stat-label Filtered / Baseline
  .stat-value {{ filteredRequests.length }} / {{ allRequests.length }}
```

### Anti-Patterns to Avoid
- **Don't show comparison when no filters active**: Creates confusing "all vs all" display with identical datasets
- **Don't make baseline more prominent than filtered**: Baseline should be subtle (lower opacity, gray) to avoid visual hierarchy confusion
- **Don't use different color schemes for baseline vs filtered**: Use same color mapping, just adjust opacity/saturation for baseline
- **Don't forget to disable comparison toggle when no filters**: Prevents user confusion about why toggle does nothing

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Chart overlay rendering | Custom canvas/SVG layering | Plotly.js multi-trace system | Handles responsive resize, zoom, pan, hover states, legend, dark mode automatically |
| Comparison toggle UI | Custom checkbox component | Existing ComparisonToggle.vue pattern | Provides consistent styling, v-model binding, active state visual feedback |
| Filter state detection | Manual filter tracking | FilterManager.hasActiveFilters() | Centralized, reliable, already reactive |
| Baseline data access | Prop drilling from parent | DataTableManager.getData() | Single source of truth, prevents stale data |
| Theme-aware colors | Hard-coded hex values | StyleManager.getColor() | Automatically adapts to light/dark mode |

**Key insight:** Plotly.js already solves the hard problems of multi-trace rendering (z-order, hover precedence, legend management, responsive sizing). The implementation complexity is in state management and passing correct datasets, not rendering.

## Common Pitfalls

### Pitfall 1: Forgetting to Check Filter State Before Rendering Baseline
**What goes wrong:** Baseline appears even when no filters active, creating visual clutter and identical datasets
**Why it happens:** Easy to forget the conditional check when adding baselineData prop to cards
**How to avoid:** Use computed property pattern `effectiveShowComparison = showComparison && hasActiveFilters`
**Warning signs:** User reports "why do I see two identical charts?" when no filters applied

### Pitfall 2: Wrong Trace Order in Multi-Trace Plots
**What goes wrong:** Filtered data appears behind baseline instead of on top, making it hard to see
**Why it happens:** Plotly renders traces in array order - first trace is in back, last trace is in front
**How to avoid:** Always push baseline trace FIRST, then filtered trace (baseline = background layer)
**Warning signs:** Baseline dominates visually, filtered data hard to see or appears "dimmed"

### Pitfall 3: Inconsistent Opacity Values Across Chart Types
**What goes wrong:** Baseline is too prominent in one chart type, too faint in another
**Why it happens:** No coordination of opacity values between histogram, pie, scatter implementations
**How to avoid:** Use consistent opacity: 0.3 for baseline bars/points, 0.5 (via '80' alpha hex) for baseline pie slices
**Warning signs:** Visual hierarchy feels off, user focuses on wrong dataset

### Pitfall 4: Not Handling Empty Baseline Dataset
**What goes wrong:** Plotly throws errors or renders broken charts when baselineData is empty array
**Why it happens:** Edge case where data loads after component mounts, or filter manager not initialized
**How to avoid:** Check `baselineData.length > 0` before pushing baseline trace to data array
**Warning signs:** Console errors like "Cannot read property 'length' of undefined" or blank charts

### Pitfall 5: Computed Property Caching Issues with Deep Objects
**What goes wrong:** Baseline chart doesn't update when data changes because computed property doesn't detect deep changes
**Why it happens:** Vue 2 computed properties don't track deep changes in arrays/objects by default
**How to avoid:** Depend on primitive values (array.length, filterManager.filterCount) not just object references
**Warning signs:** Comparison mode shows stale baseline data after filter changes

### Pitfall 6: Toggle State Not Preserved Across Tab/Route Changes
**What goes wrong:** User enables comparison mode, switches tabs, comes back - comparison mode is off
**Why it happens:** showComparison stored in component data() without persistence
**How to avoid:** Store in dashboard YAML config or global state if persistence desired (optional - local state is acceptable)
**Warning signs:** User reports "my comparison mode keeps resetting"

## Code Examples

Verified patterns from official sources and reference implementation:

### ComparisonToggle Component
```vue
<!-- Source: commuter-requests/components/controls/ComparisonToggle.vue -->
<template lang="pug">
.comparison-toggle
  label(:class="{ active: !localValue }")
    input(type="checkbox" v-model="localValue" @change="onChange")
    span.mode-label {{ localValue ? 'Focus' : 'Comparison' }}
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'ComparisonToggle',
  props: {
    modelValue: { type: Boolean, default: false },
  },

  data() {
    return {
      localValue: this.modelValue,
    }
  },

  watch: {
    modelValue(newVal) {
      this.localValue = newVal
    },
  },

  methods: {
    onChange() {
      this.$emit('update:modelValue', this.localValue)
    },
  },
})
</script>

<style scoped lang="scss">
.comparison-toggle {
  label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.4rem 0.75rem;
    background-color: var(--bgCream);
    border: 2px solid var(--borderStrong);
    border-radius: 6px;
    cursor: pointer;

    &.active {
      background-color: #3b82f6;  // Blue when comparison ON
      border-color: #2563eb;
      color: white;
    }
  }
}
</style>
```

### Dashboard-Level State Management
```typescript
// Source: commuter-requests/CommuterRequests.vue
// Add to InteractiveDashboard.vue data()
data() {
  return {
    showComparison: false,  // Toggle state
    // ... other state
  }
},

computed: {
  hasActiveFilters(): boolean {
    return this.filterManager?.hasActiveFilters() || false
  },

  // Only show comparison when toggle ON and filters active
  effectiveShowComparison(): boolean {
    return this.showComparison && this.hasActiveFilters
  },
}
```

### HistogramCard Comparison Support
```typescript
// Source: commuter-requests/components/stats/ActiveTimeHistogramPlotly.vue
interface Props {
  filteredData?: any[]        // From LinkableCardWrapper
  baselineData?: any[]        // NEW: All data for comparison
  showComparison?: boolean    // NEW: Comparison mode flag
  // ... other props
}

const props = withDefaults(defineProps<Props>(), {
  filteredData: () => [],
  baselineData: () => [],
  showComparison: false,
})

const plotData = computed(() => {
  const traces: any[] = []

  // Baseline trace (if comparison mode)
  if (props.showComparison && props.baselineData.length > 0) {
    const baselineBins = calculateBins(props.baselineData, props.column, props.binSize)
    traces.push({
      x: baselineBins.map(b => b.bin),
      y: baselineBins.map(b => b.count),
      type: 'bar',
      name: 'Baseline',
      marker: { color: 'rgba(156, 163, 175, 0.3)' },
    })
  }

  // Filtered trace
  const filteredBins = calculateBins(props.filteredData, props.column, props.binSize)
  traces.push({
    x: filteredBins.map(b => b.bin),
    y: filteredBins.map(b => b.count),
    type: 'bar',
    name: props.showComparison ? 'Filtered' : 'Data',
    marker: { color: /* selection-aware */ },
  })

  return traces
})

const plotLayout = computed(() => ({
  // ... axis config
  barmode: 'overlay',  // CRITICAL for comparison
  showlegend: props.showComparison,
}))
```

### PieChartCard Comparison Support
```typescript
// Similar structure to histogram, but with concentric domain positioning
const plotData = computed(() => {
  const traces: any[] = []

  // Inner ring - filtered
  traces.push({
    labels: filteredLabels,
    values: filteredValues,
    type: 'pie',
    hole: 0.4,
    domain: props.showComparison ? { x: [0.15, 0.85], y: [0.15, 0.85] } : undefined,
  })

  // Outer ring - baseline (if comparison)
  if (props.showComparison && props.baselineData.length > 0) {
    traces.push({
      labels: baselineLabels,
      values: baselineValues,
      type: 'pie',
      hole: 0.7,
      marker: { colors: baselineColors.map(c => c + '80') },
      textinfo: 'none',
      domain: { x: [0, 1], y: [0, 1] },
    })
  }

  return traces
})
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Static views only | Comparison mode toggle | 2025-2026 | Users can assess filter impact visually |
| Separate dashboards for comparison | Overlay rendering | Plotly.js ~2017+ | Single view shows both datasets efficiently |
| Manual trace ordering | Plotly multi-trace API | Plotly.js v1.x+ | Automatic z-order, legend, hover management |
| Hard-coded colors | StyleManager theme system | SimWrapper v4.x | Comparison works in light and dark modes |

**Deprecated/outdated:**
- Showing comparison when no filters active (creates confusion)
- Using separate charts side-by-side (takes more screen space, harder to compare)
- Custom canvas rendering for overlays (Plotly handles this better)

## Open Questions

1. **Comparison mode for MapCard**
   - What we know: MapCard already supports filtering via linkage system
   - What's unclear: Best UX for showing baseline geometries (gray overlay? separate layer?)
   - Recommendation: Start without map comparison - focus on chart cards first (COMP-02, COMP-03, COMP-04). Map comparison can be Phase 3.2

2. **Comparison mode persistence**
   - What we know: Reference implementation stores in component data() - resets on unmount
   - What's unclear: Should comparison mode persist across page reloads? Stored in URL params?
   - Recommendation: Start with non-persistent (component data), add persistence later if users request

3. **Baseline data source for DataTableCard**
   - What we know: DataTableCard currently shows all rows, dims unfiltered ones
   - What's unclear: Should "Filtered / Baseline" count appear in table header or card header?
   - Recommendation: Card header (DashboardCard component) - more visible, consistent with chart cards

4. **Comparison toggle placement**
   - What we know: Reference implementation puts toggle in table card header
   - What's unclear: Should it be in dashboard header (affects all cards) or per-card?
   - Recommendation: Dashboard header near table controls - comparison is dashboard-wide feature

## Sources

### Primary (HIGH confidence)
- SimWrapper codebase: `src/plugins/commuter-requests/` - Complete reference implementation
- SimWrapper codebase: `src/plugins/interactive-dashboard/components/cards/` - Current card implementations
- SimWrapper `package.json` - Plotly.js version 3.1.0 confirmed

### Secondary (MEDIUM confidence)
- [Plotly.js Bar Chart Reference](https://plotly.com/javascript/reference/bar/) - Official barmode documentation
- [Plotly.js Pie Chart Reference](https://plotly.com/javascript/pie-charts/) - Official pie/donut chart documentation
- [Plotly.js Scatter Reference](https://plotly.com/javascript/reference/scatter/) - Official scatter trace documentation

### Tertiary (LOW confidence - community discussions)
- [Plotly.js GitHub Issue #1973](https://github.com/plotly/plotly.js/issues/1973) - Overlay mode behavior discussions
- [Plotly Community: Nested Pie Charts](https://community.plotly.com/t/nested-pie-charts/24011) - Concentric donut techniques
- [Plotly Community: Dual Donut Chart](https://community.plotly.com/t/dual-donut-chart-different-colors/56024) - Multi-trace pie examples

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already integrated, version confirmed
- Architecture: HIGH - Complete reference implementation exists in codebase
- Pitfalls: HIGH - Derived from analysis of reference implementation patterns
- Code examples: HIGH - All examples from working codebase files

**Research date:** 2026-01-21
**Valid until:** 60 days (Plotly.js stable, reference implementation won't change)

**Key decision:** Generalize existing commuter-requests patterns rather than research new approaches - proven, tested, consistent with codebase architecture.
