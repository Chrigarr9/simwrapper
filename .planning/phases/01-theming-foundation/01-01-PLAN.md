---
phase: 01-theming-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/plugins/interactive-dashboard/managers/StyleManager.ts
  - src/plugins/interactive-dashboard/utils/colorSchemes.ts
autonomous: true

must_haves:
  truths:
    - "StyleManager class exists and exports all color definitions"
    - "CSS variables are generated on app initialization"
    - "Dark/light mode switching generates appropriate CSS variables"
  artifacts:
    - path: "src/plugins/interactive-dashboard/managers/StyleManager.ts"
      provides: "Centralized color management class"
      exports: ["StyleManager", "initializeTheme"]
      min_lines: 150
  key_links:
    - from: "StyleManager.ts"
      to: "globalStore.state.colorScheme"
      via: "Vuex store subscription"
      pattern: "globalStore\\.state\\.colorScheme"
---

<objective>
Create the StyleManager class that centralizes all color definitions and generates CSS custom properties for the interactive dashboard theming system.

Purpose: Establish the single source of truth for all colors used across dashboard components, enabling theme-wide color changes from one location.

Output: StyleManager.ts with color definitions, CSS variable generation, and theme switching capability.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-theming-foundation/01-CONTEXT.md
@src/plugins/interactive-dashboard/utils/colorSchemes.ts
@src/store.ts
@src/Globals.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StyleManager class with color definitions</name>
  <files>src/plugins/interactive-dashboard/managers/StyleManager.ts</files>
  <action>
Create StyleManager.ts in the managers folder with:

1. **Color palette definitions** (all colors as hex strings):
   - `theme.background.primary` - main dashboard background (light: #ffffff, dark: #1e293b)
   - `theme.background.secondary` - card background (light: #f8f9fa, dark: #334155)
   - `theme.background.tertiary` - subtle backgrounds (light: #f1f5f9, dark: #475569)
   - `theme.text.primary` - main text color (light: #374151, dark: #e2e8f0)
   - `theme.text.secondary` - muted text (light: #6b7280, dark: #94a3b8)
   - `theme.border.default` - standard borders (light: #e5e7eb, dark: #475569)
   - `theme.border.subtle` - subtle dividers (light: #f3f4f6, dark: #334155)

2. **Interaction state colors** (constant across modes per CONTEXT.md):
   - `interaction.hover` - #fbbf24 (orange/amber)
   - `interaction.selected` - #3b82f6 (blue)
   - `interaction.dimmed` - opacity-based (0.3 alpha)

3. **OD cluster colors** (colorblind-safe defaults):
   - `cluster.origin` - #2563eb (blue-600, deuteranopia-safe)
   - `cluster.destination` - #dc2626 (red-600, distinguishable)
   - `cluster.arc` - uses colorBy attribute (no default static color)

4. **Categorical colors** (keep existing CATEGORICAL_COLORS from colorSchemes.ts)

5. **Transport mode colors** (keep existing MODE_COLORS from colorSchemes.ts)

6. **Chart colors** (for Plotly charts):
   - `chart.bar.default` - (light: #3b82f6, dark: #60a5fa)
   - `chart.bar.selected` - (light: #ef4444, dark: #f87171)
   - `chart.grid` - (light: #e5e7eb, dark: #334155)

7. **Class structure**:
   ```typescript
   class StyleManager {
     private static instance: StyleManager | null = null;
     private currentMode: 'light' | 'dark' = 'dark';

     static getInstance(): StyleManager;
     private constructor();

     // Initialize theme and subscribe to store changes
     initialize(): void;

     // Generate and inject CSS variables
     private injectCSSVariables(): void;

     // Get color value (returns current mode's value)
     getColor(path: string): string;

     // Get RGBA array for deck.gl (convenience method)
     getColorRGBA(path: string, alpha?: number): [number, number, number, number];

     // Theme switching
     setMode(mode: 'light' | 'dark'): void;
     getMode(): 'light' | 'dark';
   }
   ```

8. **Export a convenience function**:
   ```typescript
   export function initializeTheme(): void {
     StyleManager.getInstance().initialize();
   }
   ```

Important: Subscribe to globalStore.state.colorScheme changes using Vuex watch pattern to auto-switch themes.
  </action>
  <verify>
    - File exists at src/plugins/interactive-dashboard/managers/StyleManager.ts
    - TypeScript compiles without errors: `npx tsc --noEmit src/plugins/interactive-dashboard/managers/StyleManager.ts`
    - Exports StyleManager class and initializeTheme function
  </verify>
  <done>
    - StyleManager class created with all color definitions
    - CSS variable generation method implemented
    - Vuex store subscription for theme changes
    - Singleton pattern ensures single source of truth
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CSS variable injection system</name>
  <files>src/plugins/interactive-dashboard/managers/StyleManager.ts</files>
  <action>
Extend StyleManager with CSS variable injection:

1. **CSS variable naming convention** (semantic, hierarchical):
   ```css
   --dashboard-bg-primary
   --dashboard-bg-secondary
   --dashboard-text-primary
   --dashboard-text-secondary
   --dashboard-border-default
   --dashboard-interaction-hover
   --dashboard-interaction-selected
   --dashboard-cluster-origin
   --dashboard-cluster-destination
   --dashboard-chart-bar
   --dashboard-chart-grid
   ```

2. **Injection method**:
   - Create or update a `<style id="dashboard-theme-vars">` element in document.head
   - Generate CSS with `:root { ... }` selector
   - Call injection on initialize() and whenever mode changes

3. **Variable generation logic**:
   ```typescript
   private generateCSSVariables(): string {
     const vars: string[] = [];
     // Flatten nested color object into CSS variable declarations
     this.walkColors(this.colors[this.currentMode], 'dashboard', vars);
     return `:root {\n  ${vars.join(';\n  ')};\n}`;
   }
   ```

4. **Mode-aware color retrieval**:
   - `getColor('theme.background.primary')` returns light or dark value based on currentMode
   - `getColorRGBA('interaction.hover', 200)` returns [251, 191, 36, 200] for hover state

5. **Include hex-to-RGBA utility** (move from colorSchemes.ts or duplicate):
   ```typescript
   private hexToRgba(hex: string, alpha: number = 255): [number, number, number, number]
   ```

Ensure the style element is properly cleaned up if StyleManager is ever destroyed (unlikely but good practice).
  </action>
  <verify>
    - In browser devtools, check that :root CSS variables are set after calling initializeTheme()
    - Variables update when globalStore.commit('rotateColors') is called
    - npm run dev starts without errors
  </verify>
  <done>
    - CSS variables injected into document head
    - Variables update automatically on theme change
    - getColor() and getColorRGBA() methods work correctly
  </done>
</task>

<task type="auto">
  <name>Task 3: Update colorSchemes.ts to use StyleManager</name>
  <files>src/plugins/interactive-dashboard/utils/colorSchemes.ts</files>
  <action>
Refactor colorSchemes.ts to delegate to StyleManager while maintaining backward compatibility:

1. **Keep existing exports** (MODE_COLORS, CATEGORICAL_COLORS, etc.) but have them reference StyleManager internally:
   ```typescript
   import { StyleManager } from '../managers/StyleManager';

   // Backward compatible - still exports the color maps
   // But internally consistent with StyleManager definitions
   export const MODE_COLORS = { ... };  // Keep as-is for now
   ```

2. **Add helper functions that use StyleManager**:
   ```typescript
   // Get interaction color from StyleManager
   export function getInteractionColor(state: 'hover' | 'selected' | 'dimmed'): string {
     return StyleManager.getInstance().getColor(`interaction.${state}`);
   }

   // Get cluster color from StyleManager
   export function getClusterColor(type: 'origin' | 'destination'): string {
     return StyleManager.getInstance().getColor(`cluster.${type}`);
   }

   // Get RGBA for deck.gl with interaction state
   export function getInteractionColorRGBA(
     state: 'hover' | 'selected',
     alpha?: number
   ): [number, number, number, number] {
     return StyleManager.getInstance().getColorRGBA(`interaction.${state}`, alpha);
   }
   ```

3. **Do NOT remove existing functions** - components still use getModeColor, getCategoryColor, etc.
   These will be migrated in Plan 02.

4. **Add deprecation comments** (informational, not warnings):
   ```typescript
   /**
    * @deprecated Use StyleManager.getInstance().getColor() for theme-aware colors.
    * This export maintained for backward compatibility during migration.
    */
   ```
  </action>
  <verify>
    - Existing imports from colorSchemes.ts still work
    - New helper functions getInteractionColor(), getClusterColor() return correct values
    - npm run build completes without errors
  </verify>
  <done>
    - colorSchemes.ts updated with StyleManager integration
    - Backward compatibility maintained
    - New theme-aware helper functions available
  </done>
</task>

</tasks>

<verification>
1. Run `npm run dev` - application starts without errors
2. Open browser devtools, inspect :root - CSS variables present with `--dashboard-*` prefix
3. Toggle dark/light mode via existing UI - CSS variables update
4. Import test: Create temporary test file that imports from both StyleManager and colorSchemes.ts
5. TypeScript compilation: `npm run build` completes without type errors
</verification>

<success_criteria>
1. StyleManager.ts exists with complete color palette for light and dark modes
2. CSS variables are injected on app initialization and update on theme change
3. colorSchemes.ts exports new helper functions that delegate to StyleManager
4. All existing code continues to work (no breaking changes)
5. Developer can access any theme color via CSS variable (--dashboard-*) or StyleManager.getColor()
</success_criteria>

<output>
After completion, create `.planning/phases/01-theming-foundation/01-01-SUMMARY.md`
</output>
